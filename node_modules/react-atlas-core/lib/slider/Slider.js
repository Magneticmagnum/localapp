"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = require("react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _reactThemeable = require("react-themeable");

var _reactThemeable2 = _interopRequireDefault(_reactThemeable);

var _utils = require("../utils");

var _utils2 = _interopRequireDefault(_utils);

var _events = require("../utils/events");

var _events2 = _interopRequireDefault(_events);

var _prefixer = require("../utils/prefixer");

var _prefixer2 = _interopRequireDefault(_prefixer);

var _progressBar = require("../progressBar");

var _progressBar2 = _interopRequireDefault(_progressBar);

var _input = require("../input");

var _input2 = _interopRequireDefault(_input);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Slider = function (_Component) {
  _inherits(Slider, _Component);

  function Slider() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, Slider);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Slider.__proto__ || Object.getPrototypeOf(Slider)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      "inputFocused": false,
      "inputValue": null,
      "otherKnobValue": null,
      "sliderLength": 0,
      "sliderStart": 0
    }, _this.handleInputFocus = function () {
      _this.setState({
        "inputFocused": true,
        "inputValue": _this.valueForInput(_this.props.value)
      });
    }, _this.handleInputChange = function (value) {
      var stateVal = _this.state.inputValue;
      if (_this.isRangeSlider()) {
        value.to = event;
      }
      _this.setState({ "inputValue": value });
    }, _this.handleFromInputChange = function (event) {
      var value = _this.state.inputValue;
      value.from = event;
      _this.setState({ "inputValue": value });
    }, _this.handleInputBlur = function (event) {
      var value = _this.state.inputValue || 0;
      _this.setState({ "inputFocused": false, "inputValue": null }, function () {
        _this.props.onChange(_this.prepareValue(value), event);
      });
    }, _this.handleKeyDown = function (event) {
      if ([13, 27].indexOf(event.keyCode) !== -1) {
        _this.refs.input.blur();
        _reactDom2.default.findDOMNode(_this).blur();
      }
      if (_this.isRangeSlider()) {
        return;
      }
      if (event.keyCode === 38) {
        _this.addToValue(_this.props.step);
      }
      if (event.keyCode === 40) {
        _this.addToValue(-_this.props.step);
      }
    }, _this.handleMouseDown = function (event) {
      if (_this.state.inputFocused) {
        _this.refs.input.blur();
      }
      _events2.default.addEventsToDocument(_this.getMouseEventMap());
      _this.start(_events2.default.getMousePosition(event));
      _events2.default.pauseEvent(event);
    }, _this.handleMouseMove = function (event) {
      _events2.default.pauseEvent(event);
      _this.move(_events2.default.getMousePosition(event));
    }, _this.handleMouseUp = function () {
      _this.end(_this.getMouseEventMap());
    }, _this.handleResize = function (event, callback) {
      var _ReactDOM$findDOMNode = _reactDom2.default.findDOMNode(_this.refs.progressbar).getBoundingClientRect(),
          left = _ReactDOM$findDOMNode.left,
          right = _ReactDOM$findDOMNode.right;

      var cb = callback || function () {};
      _this.setState({ "sliderStart": left, "sliderLength": right - left }, cb);
    }, _this.handleSliderBlur = function () {
      _events2.default.removeEventsFromDocument(_this.getKeyboardEvents());
    }, _this.handleSliderFocus = function () {
      _events2.default.addEventsToDocument(_this.getKeyboardEvents());
    }, _this.handleTouchEnd = function () {
      _this.end(_this.getTouchEventMap());
    }, _this.handleTouchMove = function (event) {
      _this.move(_events2.default.getTouchPosition(event));
    }, _this.handleTouchStart = function (event) {
      if (_this.state.inputFocused) {
        _this.refs.input.blur();
      }
      _this.start(_events2.default.getTouchPosition(event));
      _events2.default.addEventsToDocument(_this.getTouchEventMap());
      _events2.default.pauseEvent(event);
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Slider, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      window.addEventListener("resize", this.handleResize);
      this.handleResize();
    }
  }, {
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps, nextState) {
      if (!this.state.inputFocused && nextState.inputFocused) {
        return false;
      }
      if (this.state.inputFocused && this.props.value !== nextProps.value) {
        this.setState({ "inputValue": this.valueForInput(nextProps.value) });
        return false;
      }
      return true;
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      window.removeEventListener("resize", this.handleResize);
    }
  }, {
    key: "isRangeSlider",
    value: function isRangeSlider() {
      return isNaN(this.props.value);
    }
  }, {
    key: "addToValue",
    value: function addToValue(increment) {
      var value = this.state.inputFocused ? parseFloat(this.state.inputValue) : this.props.value;
      value = this.trimValue(value + increment);
      if (value !== this.props.value) {
        this.props.onChange(value);
      }
    }
  }, {
    key: "getKeyboardEvents",
    value: function getKeyboardEvents() {
      return {
        "keydown": this.handleKeyDown
      };
    }
  }, {
    key: "getMouseEventMap",
    value: function getMouseEventMap() {
      return {
        "mousemove": this.handleMouseMove,
        "mouseup": this.handleMouseUp
      };
    }
  }, {
    key: "getTouchEventMap",
    value: function getTouchEventMap() {
      return {
        "touchmove": this.handleTouchMove,
        "touchend": this.handleTouchEnd
      };
    }
  }, {
    key: "end",
    value: function end(revents) {
      _events2.default.removeEventsFromDocument(revents);
      this.setState({ "pressed": false, "otherKnobValue": null });
    }
  }, {
    key: "calculateKnobOffset",
    value: function calculateKnobOffset(value) {
      var _props = this.props,
          max = _props.max,
          min = _props.min,
          step = _props.step;

      return 100 * (value - min) / (max - min);
    }
  }, {
    key: "enrichNewValue",
    value: function enrichNewValue(value) {
      if (!this.isRangeSlider()) {
        return value;
      }
      var otherValue = this.state.otherKnobValue;
      return otherValue > value ? { "from": value, "to": otherValue } : { "from": otherValue, "to": value };
    }
  }, {
    key: "move",
    value: function move(position) {
      var newValue = this.positionToValue(position);
      if (newValue !== this.props.value) {
        this.props.onChange(this.enrichNewValue(newValue));
      }
    }
  }, {
    key: "positionToValue",
    value: function positionToValue(position) {
      var _state = this.state,
          start = _state["sliderStart"],
          length = _state["sliderLength"];
      var _props2 = this.props,
          max = _props2.max,
          min = _props2.min;

      return this.trimValue((position.x - start) / length * (max - min) + min);
    }
  }, {
    key: "start",
    value: function start(position) {
      var _this2 = this;

      this.setState({
        "pressed": true,
        "otherKnobValue": this.getOtherKnobValue(position)
      });
      this.handleResize(null, function () {
        return _this2.props.onChange(_this2.enrichNewValue(_this2.positionToValue(position)));
      });
    }
  }, {
    key: "getOtherKnobValue",
    value: function getOtherKnobValue(position) {
      if (!this.isRangeSlider()) {
        return null;
      }
      var currentValue = this.positionToValue(position);
      var differenceFrom = Math.abs(currentValue - this.props.value.from);
      var differenceTo = Math.abs(currentValue - this.props.value.to);
      return differenceFrom > differenceTo ? this.props.value.from : this.props.value.to;
    }
  }, {
    key: "stepDecimals",
    value: function stepDecimals() {
      return (this.props.step.toString().split(".")[1] || []).length;
    }
  }, {
    key: "trimValue",
    value: function trimValue(value) {
      if (value < this.props.min) {
        return this.props.min;
      }
      if (value > this.props.max) {
        return this.props.max;
      }
      return _utils2.default.round(value, this.stepDecimals());
    }
  }, {
    key: "prepareValue",
    value: function prepareValue(value) {
      if (!this.isRangeSlider()) {
        return this.trimValue(value);
      }
      value.from = this.trimValue(value.from);
      value.to = this.trimValue(value.to);
      if (value.from > value.to) {
        var temp = value.to;
        value.to = value.from;
        value.from = temp;
      }
      return value;
    }
  }, {
    key: "convertValue",
    value: function convertValue(value) {
      var decimals = this.stepDecimals();
      return decimals > 0 ? value.toFixed(decimals) : value.toString();
    }
  }, {
    key: "valueForInput",
    value: function valueForInput(value) {
      if (this.isRangeSlider()) {
        return {
          "from": this.convertValue(value.from),
          "to": this.convertValue(value.to)
        };
      }
      return this.convertValue(value);
    }
  }, {
    key: "valueForKnob",
    value: function valueForKnob(isLast) {
      if (!this.isRangeSlider()) {
        return this.props.value;
      }
      return isLast ? this.props.value.to : this.props.value.from;
    }
  }, {
    key: "renderKnob",
    value: function renderKnob(isLast, theme) {
      var knobValue = this.valueForKnob(isLast);
      var offset = this.calculateKnobOffset(knobValue);
      var knobStyles = (0, _prefixer2.default)({ "left": offset + "%" });
      var className = (0, _utils.classNames)("innerknob", {
        "pressed": knobValue !== this.state.otherKnobValue
      });
      var ref = isLast ? "knob" : "knobFrom";
      return _react2.default.createElement(
        "div",
        _extends({
          ref: ref
        }, theme(10, "knob"), {
          onMouseDown: this.handleMouseDown,
          onTouchStart: this.handleTouchStart,
          style: knobStyles
        }),
        _react2.default.createElement("div", _extends({}, theme.apply(undefined, [11].concat(_toConsumableArray(className))), {
          "data-value": parseInt(this.valueForKnob(isLast))
        }))
      );
    }
  }, {
    key: "renderSnaps",
    value: function renderSnaps(theme) {
      if (this.props.snaps) {
        return _react2.default.createElement(
          "div",
          _extends({ ref: "snaps" }, theme(12, "snaps")),
          _utils2.default.range(0, (this.props.max - this.props.min) / this.props.step).map(function (i) {
            return _react2.default.createElement("div", _extends({ key: "span-" + i }, theme(13, "snap")));
          })
        );
      }
    }
  }, {
    key: "renderInput",
    value: function renderInput(isLast, theme) {
      if (this.props.editable) {
        var value = this.state.inputFocused ? this.state.inputValue : this.valueForInput(this.props.value);
        if (this.isRangeSlider()) {
          value = isLast ? value.to : value.from;
        }
        var ref = isLast ? "input" : "inputFrom";
        return _react2.default.createElement(_input2.default, _extends({
          ref: ref
        }, theme(14, "input"), {
          onFocus: this.handleInputFocus,
          onChange: isLast ? this.handleInputChange : this.handleFromInputChange,
          onBlur: this.handleInputBlur,
          value: value,
          theme: this.props.theme
        }));
      }
    }
  }, {
    key: "render",
    value: function render() {
      var theme = (0, _reactThemeable2.default)(this.props.theme);
      var className = (0, _utils.classNames)("root", {
        "editable": this.props.editable,
        "pinned": this.props.pinned,
        "pressed": this.state.pressed,
        "ring": this.props.value === this.props.min
      }, this.props.className);

      return _react2.default.createElement(
        "div",
        _extends({}, theme.apply(undefined, [15].concat(_toConsumableArray(className))), {
          onBlur: this.handleSliderBlur,
          onFocus: this.handleSliderFocus,
          tabIndex: "0"
        }),
        this.isRangeSlider() ? this.renderInput(false, theme) : null,
        _react2.default.createElement(
          "div",
          _extends({
            ref: "slider"
          }, theme(16, "container"), {
            onMouseDown: this.handleMouseDown,
            onTouchStart: this.handleTouchStart
          }),
          this.isRangeSlider() ? this.renderKnob(false, theme) : "",
          this.renderKnob(true, theme),
          _react2.default.createElement(
            "div",
            theme(17, "progress"),
            _react2.default.createElement(_progressBar2.default, _extends({
              ref: "progressbar"
            }, theme(18, "innerprogress"), {
              max: this.props.max,
              min: this.props.min,
              mode: "determinate",
              transitionDuration: "0s",
              value: this.props.value,
              theme: this.props.theme
            })),
            this.props.snaps ? _react2.default.createElement(
              "div",
              _extends({ ref: "snaps" }, theme(19, "snaps")),
              _utils2.default.range(0, (this.props.max - this.props.min) / this.props.step).map(function (i) {
                return _react2.default.createElement("div", _extends({ key: "span-" + i }, theme(20, "snap")));
              })
            ) : null
          )
        ),
        this.renderInput(true, theme)
      );
    }
  }]);

  return Slider;
}(_react.Component);

Slider.defaultProps = {
  "className": "",
  "editable": false,
  "max": 100,
  "min": 0,
  "pinned": false,
  "snaps": false,
  "step": 0.01,
  "value": 0
};

exports.default = Slider;